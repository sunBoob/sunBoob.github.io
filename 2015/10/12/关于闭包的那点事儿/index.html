<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="SunBoBo"><link rel="alternative" href="/atom.xml" title="SunBoBo" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>关于闭包的那点事儿 - SunBoBo</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">SunBoBo</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2015-10-11T16:00:00.000Z">October 12, 2015</time><h1 class="post__title"><a href="/2015/10/12/关于闭包的那点事儿/">关于闭包的那点事儿</a></h1><div class="post__main echo"><p>​    今天和大家分享点什么呢？说说<strong>闭包</strong>吧，没事儿翻了翻资料，有好多东西都忘了。看到这个<strong>闭包</strong>，觉得还挺有意思的 ，就和大家扯一扯。</p>
<h2 id="一、什么是闭包？"><a href="#一、什么是闭包？" class="headerlink" title="一、什么是闭包？"></a>一、什么是闭包？</h2><p>​    那么首先的第一个问题是什么呢？那肯定是要说<strong>闭包</strong>是什么？</p>
<p>​    <strong>闭包</strong>从字面的意义上来看呢，<strong>闭包</strong>就是封闭的包裹结构，在 js 中 <strong>闭包</strong>就是函数在运行的时候，构成的一个封闭空间，就像一个异次元空间一样。</p>
<p>​    那么具体是什么个意思呢？比方说，我们创建了一个函数，这个函数被定义了之后，就写在那里，不调用，就是一个普普通通的对象，不会创建任何的内存，也不会影响到其他的任何东西。只有当函数运行起来的时候，在函数执行过程中，结束之前，函数会构成一个封闭的空间。这个封闭的空间就是闭包。</p>
<hr>
<h2 id="二、闭包的作用"><a href="#二、闭包的作用" class="headerlink" title="二、闭包的作用"></a>二、闭包的作用</h2><p>​    那就有人问了，这闭包到底有什么作用呢？？其实要不是在实际的工作中发现了闭包的好处，我也不会特意查了这么多关于闭包的问题。下面咱们就说说闭包的作用。</p>
<h3 id="1、闭包的应用"><a href="#1、闭包的应用" class="headerlink" title="1、闭包的应用"></a>1、闭包的应用</h3><p>​    首先我们来思考一个问题，闭包到底给我们构成了一个什么样的东西，也就是说，有闭包和没有闭包有什么不同呢？闭包又给我们提供了一个什么样的功能呢？？</p>
<p>​    首先，不得不说一下，闭包如果要使用的话，需要一个经典的代码    ，是一定要有的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function 函数名fn()&#123;</div><div class="line">  //数据</div><div class="line">  var num;</div><div class="line">  function 函数名fun()&#123;</div><div class="line">  //具有访问的能力</div><div class="line">  	return num;</div><div class="line">  &#125;</div><div class="line">  return fun;</div><div class="line">&#125;</div><div class="line">var f = fn();</div></pre></td></tr></table></figure>
<p>​    此时闭包改变了变量的访问规则，也就是改变了作用域，有人还说他是个桥梁，我觉得可以这么理解: 闭包给我们提供了一个私有作用域。凡是需要保护和使用的数据都可以放在私有作用域中。</p>
<p>​    那么，这个时候就出现了一个非常神奇的模式，完美的实现了闭包的作用。</p>
<hr>
<h2 id="三、沙箱模式"><a href="#三、沙箱模式" class="headerlink" title="三、沙箱模式"></a>三、沙箱模式</h2><p>​    这个神奇的模式，就是传说中的沙箱模式！那么，我们来思考一下，什么是沙箱呢？</p>
<h3 id="1、什么是沙箱"><a href="#1、什么是沙箱" class="headerlink" title="1、什么是沙箱"></a>1、什么是沙箱</h3><p>​    我们来举个例子吧，比方说，你在网上下载了一个软件，我们并不知道这个这个软件有没有病毒，一般的杀毒软件会提供一个沙箱运行模式，其特点就是在里面运行的任何程序，在沙箱重启以后，其影响会全部消失，但是沙箱会模拟当前操作系统的所有访问资源，相信大家都去过网吧吧？大家应都能感受到，网吧的电脑，一旦重启之后，你下载的所有的东西就都不见了，大概就是这么个意思。</p>
<p>​    而这种沙箱模式，在很多手机app中也有相应的体现，例如，一个软件是个万恶的病毒，安装了以后，理论上只允许其在自己所在的沙箱里运行，不允许访问其他app所在的文件。而万能的苹果 iOS系统，就是运用的这样的技术，你把你的苹果连到电脑上，系统中的app的文件，你是怎么样都找不到的，访问不了，如果想访问，好的，越域去。而安卓机，则是可以在电脑上随意的访问，甚至可以在手机上还自带文件管理这一项功能，这也就是人们为什么说苹果安全的原因。</p>
<hr>
<h3 id="2、沙箱的特点"><a href="#2、沙箱的特点" class="headerlink" title="2、沙箱的特点"></a>2、沙箱的特点</h3><p>​    因此沙箱的特点就是: 既可以运行，又可以做到内外隔离。</p>
<p>​    <strong>那么我们什么时候会用到沙箱呢？</strong></p>
<p>​    在 js 中，咱们自己在封装一些东西的时候，容易出现全局污染，（<em>啊，当然了，对于像我这种，自己压根没有多少代码库存的同志来说，貌似用不到。just kidding</em>），这个时候，我们就可以考虑将自己封装的代码，放到一个沙箱中，留出一个允许别人使用的接口（可以是函数，也可以是对象）。我们的代码就不会，或是以最小的情况影响到外界代码。</p>
<p>​    简单的说，就是想让我们的代码不影响外界，但是还想运行我们的代码，这时候就可以用到沙箱了。</p>
<hr>
<h3 id="3、沙箱的实现"><a href="#3、沙箱的实现" class="headerlink" title="3、沙箱的实现"></a>3、沙箱的实现</h3><p>​    那沙箱要怎么实现呢？可以利用下面的代码构成沙箱,灰常简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line"> 		//代码</div><div class="line"> 		//1,...</div><div class="line"> 		//2,...</div><div class="line"> 		//3,...</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>​    这是一个自调用函数，由于是立即执行函数，代码放在这里，不管是声明任何变量，使用任何数据，都不会影响到外界的代码，从而既能保证这段代码的执行，又能保证不会影响外界的代码。</p>
<p>​    所以沙箱模式，就是一个最简单的闭包。</p>
<hr>
<h3 id="4、返回接口的方法"><a href="#4、返回接口的方法" class="headerlink" title="4、返回接口的方法"></a>4、返回接口的方法</h3><p>​    那么，现在问题来了，沙箱模式可以保证数据内外隔离，但是在开发中，我们需要预留一些 api，以供外界调用，那沙箱是怎么返回的呢？我找到了几种方法，我们一起来看一下。</p>
<h4 id="1-gt-利用-返回值-，返回一个接口"><a href="#1-gt-利用-返回值-，返回一个接口" class="headerlink" title="1 ~~&gt; 利用 返回值 ，返回一个接口"></a>1 ~~&gt; 利用 返回值 ，返回一个接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var fun = (function()&#123;</div><div class="line"> 		//...</div><div class="line"> 		return fun;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>​    那么我们来考虑一下，这个方法可以返回一个接口，那如果，我们想返回多个数据呢？我们来看下下面的这个方法。</p>
<h4 id="2-gt-利用-window-的属性返回多个数据"><a href="#2-gt-利用-window-的属性返回多个数据" class="headerlink" title="2 ~~&gt; 利用 window 的属性返回多个数据"></a>2 ~~&gt; 利用 window 的属性返回多个数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line"> 		//...</div><div class="line"> 		window.jQuery = window.$ = jQuery;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>​    看着眼熟吗？对没错，jQuery中用的就是这种方法，但是我们可以看一下js 中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(function( global, factory ) &#123;</div><div class="line"></div><div class="line">	</div><div class="line">		factory( global );</div><div class="line"></div><div class="line">// Pass this if window is not defined yet</div><div class="line">&#125;(window , function( window, noGlobal ) &#123;</div><div class="line">	</div><div class="line">	// jq 源代码</div><div class="line"></div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p> 等价于这个, 1.7 以前 都是这么写的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function ( window, noGlobal ) &#123;</div><div class="line"></div><div class="line">// jq 源代码</div><div class="line">window.xxx = xxx;</div><div class="line"></div><div class="line">&#125;)( window );</div></pre></td></tr></table></figure>
<p>​    我们发现，jQuery 的沙箱应用中，传入了window。这是为什么呢？</p>
<p>​    要么说，jQuery的创始人John Resig ,是个大神呢，传入window有两点好处。</p>
<p>​    1、减少变量的搜索层级，提高了一点点的效率，我们常说，性能是一点点节约出来的。所以别看一点点，积累起来 ，也是很庞大的。</p>
<p>​    2、在代码中，凡是使用window的地方，都可以变成局部变量名，在代码压缩的过程中可以被混淆成一个或单个的字符，这样可以节约字节。增加压缩效果，我们又常说，文件的大小是从一个字节节约起来，所以也别看这是一点点，…咳咳，后面的省略号吧 ，属实是不想重复这句话了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(function (  noGlobal ) &#123;</div><div class="line"></div><div class="line">// jq 源代码</div><div class="line">window.xxx = xxx;</div><div class="line"></div><div class="line">w.xxxx = xxxx;</div><div class="line"></div><div class="line">&#125;)(  );</div><div class="line"></div><div class="line"></div><div class="line">(function ( w, noGlobal ) &#123;</div><div class="line"></div><div class="line">// jq 源代码</div><div class="line">w.xxx = xxx;</div><div class="line"></div><div class="line">&#125;)( window );</div></pre></td></tr></table></figure>
<p>​    就这两种吗？当然不是，下面还有一种写法，也是比较常见的写法</p>
<h4 id="3-gt-函数在调用时，默认函数中的this就是window，因此第2种写法有一个变体"><a href="#3-gt-函数在调用时，默认函数中的this就是window，因此第2种写法有一个变体" class="headerlink" title="3 ~~&gt; 函数在调用时，默认函数中的this就是window，因此第2种写法有一个变体"></a>3 ~~&gt; 函数在调用时，默认函数中的this就是window，因此第2种写法有一个变体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  //...</div><div class="line">  this.jQuery = this.$ = jQuery;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<hr>
<h2 id="四、利用闭包实现私有作用域（带有私有作用域的函数）"><a href="#四、利用闭包实现私有作用域（带有私有作用域的函数）" class="headerlink" title="四、利用闭包实现私有作用域（带有私有作用域的函数）"></a>四、利用闭包实现私有作用域（<em>带有私有作用域的函数</em>）</h2><p>​    代码模型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//一般写函数</div><div class="line">var foo = function () &#123;</div><div class="line">       // 函数体</div><div class="line">     &#125;;</div></pre></td></tr></table></figure>
<p> 可以使得函数具有私有内存</p>
<pre><code>var foo = (function () {
  // 私有内存空间
  return function () {
    // 函数体
  };
})();
</code></pre><p>这个带有私有内存的函数，在实际开发中可以不使用，但是如果使用，会比较方便。</p>
<hr>
<h2 id="五、函数如果带有内存的好处"><a href="#五、函数如果带有内存的好处" class="headerlink" title="五、函数如果带有内存的好处"></a>五、函数如果带有内存的好处</h2><p>​    在我们日常的开发当中，非常注重页面计算，运行的效率，而带有内存的函数就是提高行效率的一个非常好的方法。</p>
<p>​    先给大家举个例子吧，大家都知道Fibonacci数列吧？使用递归来实现的，但是呢，我们回想一下，递归的性能属实是太低了。我给大家找到了这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//我们来声明一个变量，俩记录执行的次数</div><div class="line">var count = 0;</div><div class="line">   //设置计算函数</div><div class="line">   function fib( n ) &#123;</div><div class="line">     count++;</div><div class="line">     if ( n == 0 || n == 1 ) return 1;</div><div class="line">     return fib( n - 1 ) + fib( n - 2 );</div><div class="line">   &#125;</div><div class="line"></div><div class="line">//将计算结果取出来，并将计数变量清0</div><div class="line">   function run( n ) &#123;</div><div class="line">     count = 0;</div><div class="line">     var res = fib( n );</div><div class="line">//打印一下</div><div class="line">     console.log( &apos;fib( &apos; + n + &apos; ) = &apos; + res + &apos;, count = &apos; + count  );</div><div class="line">   &#125;</div><div class="line">//循环调用，咱们来个50次看看效果。</div><div class="line">   for ( var i = 0; i &lt; 50; i++ ) &#123;</div><div class="line">     run( i );</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>​    来看看浏览器console中的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">fib( 0 ) = 1, count = 1</div><div class="line">fib( 1 ) = 1, count = 1</div><div class="line">fib( 2 ) = 2, count = 3</div><div class="line">fib( 3 ) = 3, count = 5</div><div class="line">fib( 4 ) = 5, count = 9</div><div class="line">fib( 5 ) = 8, count = 15</div><div class="line">fib( 6 ) = 13, count = 25</div><div class="line">fib( 7 ) = 21, count = 41</div><div class="line">fib( 8 ) = 34, count = 67</div><div class="line">fib( 9 ) = 55, count = 109</div><div class="line">fib( 10 ) = 89, count = 177</div><div class="line">fib( 11 ) = 144, count = 287</div><div class="line">fib( 12 ) = 233, count = 465</div><div class="line">fib( 13 ) = 377, count = 753</div><div class="line">fib( 14 ) = 610, count = 1219</div><div class="line">fib( 15 ) = 987, count = 1973</div><div class="line">fib( 16 ) = 1597, count = 3193</div><div class="line">fib( 17 ) = 2584, count = 5167</div><div class="line">fib( 18 ) = 4181, count = 8361</div><div class="line">fib( 19 ) = 6765, count = 13529</div><div class="line">fib( 20 ) = 10946, count = 21891</div><div class="line">fib( 21 ) = 17711, count = 35421</div><div class="line">fib( 22 ) = 28657, count = 57313</div><div class="line">fib( 23 ) = 46368, count = 92735</div><div class="line">fib( 24 ) = 75025, count = 150049</div><div class="line">fib( 25 ) = 121393, count = 242785</div><div class="line">fib( 26 ) = 196418, count = 392835</div><div class="line">fib( 27 ) = 317811, count = 635621</div><div class="line">fib( 28 ) = 514229, count = 1028457</div><div class="line">fib( 29 ) = 832040, count = 1664079</div><div class="line">fib( 30 ) = 1346269, count = 2692537</div><div class="line">fib( 31 ) = 2178309, count = 4356617</div><div class="line">fib( 32 ) = 3524578, count = 7049155</div><div class="line">fib( 33 ) = 5702887, count = 11405773</div><div class="line">fib( 34 ) = 9227465, count = 18454929</div><div class="line">fib( 35 ) = 14930352, count = 29860703</div><div class="line">fib( 36 ) = 24157817, count = 48315633</div><div class="line">fib( 37 ) = 39088169, count = 78176337</div><div class="line">fib( 38 ) = 63245986, count = 126491971</div><div class="line">fib( 39 ) = 102334155, count = 204668309</div><div class="line">fib( 40 ) = 165580141, count = 331160281</div><div class="line">fib( 41 ) = 267914296, count = 535828591</div><div class="line">fib( 42 ) = 433494437, count = 866988873</div></pre></td></tr></table></figure>
<p>​    不是说打印50次吗？？怎么只有42次呢？呵呵，不是我偷懒，是因为我浏览器崩掉了，咱们来看一下，count计数急了多少次，个…十…百…千…万….8亿次，8亿次，8亿次。重要的事情说三遍。</p>
<p>​    什么概念？这还没再往下呢，再往下，回到什么程度，我真的不敢想，难怪我的浏览器垮掉了。</p>
<p>​    那现在来给大家，分析一下计算慢的原因:</p>
<p>​    该数列的计算慢是因为重复的在进行计算，例如计算fib(5) , 需要先计算fib(4) , fib(3) , 要等着，但是在计算fib(4) , 的时候，其实也会计算fib(3) , 只是在计算完fib(4), 的时候fib(3) , 又要再计算一次，因此有很多的重复计算，而且数字越大重复的次数越多，以至于在计算fib(44) , 的时候，已经超过十亿次了。可想而这，这性能能高吗？</p>
<p>​    如果要提高其性能，最简单的处理办法就是将计算的结果缓存起来，再次计算的时候，先看看有没有缓存，如果有，直接拿来用，如果没有再计算，并且将计算的结果再缓存起来。</p>
<pre><code>var count = 0;
  //先给缓存数组cache添加前两个值
  var cache = [ 1, 1 ];
  var fib = function ( n ) {
    count++;
    var ret = cache[ n ];
    if ( ret ) {
      // 不是 undefined，表示找到了，返回这个值
      return ret;
    } else {
      // 是 undefined，表示没找到，然后进行计算，并缓存到缓存数组中
      ret = fib( n - 1 ) + fib( n - 2 );
      cache[ n ] = ret;
      return ret;
    }
  };

  function run( n ) {
    count = 0;
    cache = [ 1, 1 ];
    var res = fib( n );

    console.log( &apos;fib( &apos; + n + &apos; ) = &apos; + res + &apos;, count = &apos; + count  );
  }

  for ( var i = 0; i &lt; 50; i++ ) {
    run( i );
  }
</code></pre><p>​    再来看看console中都得结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">fib( 0 ) = 1, count = 1</div><div class="line">   fib( 1 ) = 1, count = 1</div><div class="line">   fib( 2 ) = 2, count = 3</div><div class="line">   fib( 3 ) = 3, count = 5</div><div class="line">   fib( 4 ) = 5, count = 7</div><div class="line">   fib( 5 ) = 8, count = 9</div><div class="line">   fib( 6 ) = 13, count = 11</div><div class="line">   fib( 7 ) = 21, count = 13</div><div class="line">   fib( 8 ) = 34, count = 15</div><div class="line">   fib( 9 ) = 55, count = 17</div><div class="line">   fib( 10 ) = 89, count = 19</div><div class="line">   fib( 11 ) = 144, count = 21</div><div class="line">   fib( 12 ) = 233, count = 23</div><div class="line">   fib( 13 ) = 377, count = 25</div><div class="line">   fib( 14 ) = 610, count = 27</div><div class="line">   fib( 15 ) = 987, count = 29</div><div class="line">   fib( 16 ) = 1597, count = 31</div><div class="line">   fib( 17 ) = 2584, count = 33</div><div class="line">   fib( 18 ) = 4181, count = 35</div><div class="line">   fib( 19 ) = 6765, count = 37</div><div class="line">   fib( 20 ) = 10946, count = 39</div><div class="line">   fib( 21 ) = 17711, count = 41</div><div class="line">   fib( 22 ) = 28657, count = 43</div><div class="line">   fib( 23 ) = 46368, count = 45</div><div class="line">   fib( 24 ) = 75025, count = 47</div><div class="line">   fib( 25 ) = 121393, count = 49</div><div class="line">   fib( 26 ) = 196418, count = 51</div><div class="line">   fib( 27 ) = 317811, count = 53</div><div class="line">   fib( 28 ) = 514229, count = 55</div><div class="line">   fib( 29 ) = 832040, count = 57</div><div class="line">   fib( 30 ) = 1346269, count = 59</div><div class="line">   fib( 31 ) = 2178309, count = 61</div><div class="line">   fib( 32 ) = 3524578, count = 63</div><div class="line">   fib( 33 ) = 5702887, count = 65</div><div class="line">   fib( 34 ) = 9227465, count = 67</div><div class="line">   fib( 35 ) = 14930352, count = 69</div><div class="line">   fib( 36 ) = 24157817, count = 71</div><div class="line">   fib( 37 ) = 39088169, count = 73</div><div class="line">   fib( 38 ) = 63245986, count = 75</div><div class="line">   fib( 39 ) = 102334155, count = 77</div><div class="line">   fib( 40 ) = 165580141, count = 79</div><div class="line">   fib( 41 ) = 267914296, count = 81</div><div class="line">   fib( 42 ) = 433494437, count = 83</div><div class="line">   fib( 43 ) = 701408733, count = 85</div><div class="line">   fib( 44 ) = 1134903170, count = 87</div><div class="line">   fib( 45 ) = 1836311903, count = 89</div><div class="line">   fib( 46 ) = 2971215073, count = 91</div><div class="line">   fib( 47 ) = 4807526976, count = 93</div><div class="line">   fib( 48 ) = 7778742049, count = 95</div><div class="line">   fib( 49 ) = 12586269025, count = 97</div></pre></td></tr></table></figure>
<p>​    在看看这性能，怎么样，这不是几倍，几十倍的问题啊 ，这是成千上万倍的提升了性能，别说打印50次了，就是150次，50次，多时刷刷的。所以，由此可见缓存功能是由多么的强大，哈哈，有兴趣的小伙伴，也可以多查一查有关于这方面的知识，记得分享给我哦。今天就到这儿了。</p>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2017 SunBoBo</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>